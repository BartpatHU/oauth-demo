{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/patrik.bartus/Desktop/oauth-demo/oauth-demo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, Inject, NgModule, InjectionToken } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { Subject, of, from, race, throwError, combineLatest, merge } from 'rxjs';\nimport { filter, tap, debounceTime, delay, switchMap, map, first, catchError, timeout, take, mergeMap } from 'rxjs/operators';\nimport fsha256 from 'fast-sha256';\n\nclass DateTimeProvider {}\n\nlet SystemDateTimeProvider = /*#__PURE__*/(() => {\n  class SystemDateTimeProvider extends DateTimeProvider {\n    now() {\n      return Date.now();\n    }\n\n    new() {\n      return new Date();\n    }\n\n  }\n\n  SystemDateTimeProvider.ɵfac = /* @__PURE__ */function () {\n    let ɵSystemDateTimeProvider_BaseFactory;\n    return function SystemDateTimeProvider_Factory(t) {\n      return (ɵSystemDateTimeProvider_BaseFactory || (ɵSystemDateTimeProvider_BaseFactory = i0.ɵɵgetInheritedFactory(SystemDateTimeProvider)))(t || SystemDateTimeProvider);\n    };\n  }();\n\n  SystemDateTimeProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SystemDateTimeProvider,\n    factory: SystemDateTimeProvider.ɵfac\n  });\n  return SystemDateTimeProvider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Additional options that can be passed to tryLogin.\r\n */\n\n\nclass LoginOptions {\n  constructor() {\n    /**\r\n     * Set this to true to disable the nonce\r\n     * check which is used to avoid\r\n     * replay attacks.\r\n     * This flag should never be true in\r\n     * production environments.\r\n     */\n    this.disableNonceCheck = false;\n    /**\r\n     * Normally, you want to clear your hash fragment after\r\n     * the lib read the token(s) so that they are not displayed\r\n     * anymore in the url. If not, set this to true. For code flow\r\n     * this controls removing query string values.\r\n     */\n\n    this.preventClearHashAfterLogin = false;\n  }\n\n}\n/**\r\n * Defines the logging interface the OAuthService uses\r\n * internally. Is compatible with the `console` object,\r\n * but you can provide your own implementation as well\r\n * through dependency injection.\r\n */\n\n\nclass OAuthLogger {}\n/**\r\n * Defines a simple storage that can be used for\r\n * storing the tokens at client side.\r\n * Is compatible to localStorage and sessionStorage,\r\n * but you can also create your own implementations.\r\n */\n\n\nclass OAuthStorage {}\n\nlet MemoryStorage = /*#__PURE__*/(() => {\n  class MemoryStorage {\n    constructor() {\n      this.data = new Map();\n    }\n\n    getItem(key) {\n      return this.data.get(key);\n    }\n\n    removeItem(key) {\n      this.data.delete(key);\n    }\n\n    setItem(key, data) {\n      this.data.set(key, data);\n    }\n\n  }\n\n  MemoryStorage.ɵfac = function MemoryStorage_Factory(t) {\n    return new (t || MemoryStorage)();\n  };\n\n  MemoryStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MemoryStorage,\n    factory: MemoryStorage.ɵfac\n  });\n  return MemoryStorage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Represents the received tokens, the received state\r\n * and the parsed claims from the id-token.\r\n */\n\n\nclass ReceivedTokens {}\n\nclass OAuthEvent {\n  constructor(type) {\n    this.type = type;\n  }\n\n}\n\nclass OAuthSuccessEvent extends OAuthEvent {\n  constructor(type, info = null) {\n    super(type);\n    this.info = info;\n  }\n\n}\n\nclass OAuthInfoEvent extends OAuthEvent {\n  constructor(type, info = null) {\n    super(type);\n    this.info = info;\n  }\n\n}\n\nclass OAuthErrorEvent extends OAuthEvent {\n  constructor(type, reason, params = null) {\n    super(type);\n    this.reason = reason;\n    this.params = params;\n  }\n\n} // see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\n\n\nfunction b64DecodeUnicode(str) {\n  const base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n  return decodeURIComponent(atob(base64).split('').map(function (c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\n\nfunction base64UrlEncode(str) {\n  const base64 = btoa(str);\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nclass AuthConfig {\n  constructor(json) {\n    /**\r\n     * The client's id as registered with the auth server\r\n     */\n    this.clientId = '';\n    /**\r\n     * The client's redirectUri as registered with the auth server\r\n     */\n\n    this.redirectUri = '';\n    /**\r\n     * An optional second redirectUri where the auth server\r\n     * redirects the user to after logging out.\r\n     */\n\n    this.postLogoutRedirectUri = '';\n    /**\r\n     * Defines whether to use 'redirectUri' as a replacement\r\n     * of 'postLogoutRedirectUri' if the latter is not set.\r\n     */\n\n    this.redirectUriAsPostLogoutRedirectUriFallback = true;\n    /**\r\n     * The auth server's endpoint that allows to log\r\n     * the user in when using implicit flow.\r\n     */\n\n    this.loginUrl = '';\n    /**\r\n     * The requested scopes\r\n     */\n\n    this.scope = 'openid profile';\n    this.resource = '';\n    this.rngUrl = '';\n    /**\r\n     * Defines whether to use OpenId Connect during\r\n     * implicit flow.\r\n     */\n\n    this.oidc = true;\n    /**\r\n     * Defines whether to request an access token during\r\n     * implicit flow.\r\n     */\n\n    this.requestAccessToken = true;\n    this.options = null;\n    /**\r\n     * The issuer's uri.\r\n     */\n\n    this.issuer = '';\n    /**\r\n     * The logout url.\r\n     */\n\n    this.logoutUrl = '';\n    /**\r\n     * Defines whether to clear the hash fragment after logging in.\r\n     */\n\n    this.clearHashAfterLogin = true;\n    /**\r\n     * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\r\n     */\n\n    this.tokenEndpoint = null;\n    /**\r\n     * Url of the revocation endpoint as defined by OpenId Connect and OAuth 2.\r\n     */\n\n    this.revocationEndpoint = null;\n    /**\r\n     * Names of known parameters sent out in the TokenResponse. https://tools.ietf.org/html/rfc6749#section-5.1\r\n     */\n\n    this.customTokenParameters = [];\n    /**\r\n     * Url of the userinfo endpoint as defined by OpenId Connect.\r\n     */\n\n    this.userinfoEndpoint = null;\n    this.responseType = '';\n    /**\r\n     * Defines whether additional debug information should\r\n     * be shown at the console. Note that in certain browsers\r\n     * the verbosity of the console needs to be explicitly set\r\n     * to include Debug level messages.\r\n     */\n\n    this.showDebugInformation = false;\n    /**\r\n     * The redirect uri used when doing silent refresh.\r\n     */\n\n    this.silentRefreshRedirectUri = '';\n    this.silentRefreshMessagePrefix = '';\n    /**\r\n     * Set this to true to display the iframe used for\r\n     * silent refresh for debugging.\r\n     */\n\n    this.silentRefreshShowIFrame = false;\n    /**\r\n     * Timeout for silent refresh.\r\n     * @internal\r\n     * depreacted b/c of typo, see silentRefreshTimeout\r\n     */\n\n    this.siletRefreshTimeout = 1000 * 20;\n    /**\r\n     * Timeout for silent refresh.\r\n     */\n\n    this.silentRefreshTimeout = 1000 * 20;\n    /**\r\n     * Some auth servers don't allow using password flow\r\n     * w/o a client secret while the standards do not\r\n     * demand for it. In this case, you can set a password\r\n     * here. As this password is exposed to the public\r\n     * it does not bring additional security and is therefore\r\n     * as good as using no password.\r\n     */\n\n    this.dummyClientSecret = null;\n    /**\r\n     * Defines whether https is required.\r\n     * The default value is remoteOnly which only allows\r\n     * http for localhost, while every other domains need\r\n     * to be used with https.\r\n     */\n\n    this.requireHttps = 'remoteOnly';\n    /**\r\n     * Defines whether every url provided by the discovery\r\n     * document has to start with the issuer's url.\r\n     */\n\n    this.strictDiscoveryDocumentValidation = true;\n    /**\r\n     * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\r\n     * with keys used to validate received id_tokens.\r\n     * This is taken out of the disovery document. Can be set manually too.\r\n     */\n\n    this.jwks = null;\n    /**\r\n     * Map with additional query parameter that are appended to\r\n     * the request when initializing implicit flow.\r\n     */\n\n    this.customQueryParams = null;\n    this.silentRefreshIFrameName = 'angular-oauth-oidc-silent-refresh-iframe';\n    /**\r\n     * Defines when the token_timeout event should be raised.\r\n     * If you set this to the default value 0.75, the event\r\n     * is triggered after 75% of the token's life time.\r\n     */\n\n    this.timeoutFactor = 0.75;\n    /**\r\n     * If true, the lib will try to check whether the user\r\n     * is still logged in on a regular basis as described\r\n     * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n     */\n\n    this.sessionChecksEnabled = false;\n    /**\r\n     * Interval in msec for checking the session\r\n     * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n     */\n\n    this.sessionCheckIntervall = 3 * 1000;\n    /**\r\n     * Url for the iframe used for session checks\r\n     */\n\n    this.sessionCheckIFrameUrl = null;\n    /**\r\n     * Name of the iframe to use for session checks\r\n     */\n\n    this.sessionCheckIFrameName = 'angular-oauth-oidc-check-session-iframe';\n    /**\r\n     * This property has been introduced to disable at_hash checks\r\n     * and is indented for Identity Provider that does not deliver\r\n     * an at_hash EVEN THOUGH its recommended by the OIDC specs.\r\n     * Of course, when disabling these checks then we are bypassing\r\n     * a security check which means we are more vulnerable.\r\n     */\n\n    this.disableAtHashCheck = false;\n    /**\r\n     * Defines wether to check the subject of a refreshed token after silent refresh.\r\n     * Normally, it should be the same as before.\r\n     */\n\n    this.skipSubjectCheck = false;\n    this.useIdTokenHintForSilentRefresh = false;\n    /**\r\n     * Defined whether to skip the validation of the issuer in the discovery document.\r\n     * Normally, the discovey document's url starts with the url of the issuer.\r\n     */\n\n    this.skipIssuerCheck = false;\n    /**\r\n     * final state sent to issuer is built as follows:\r\n     * state = nonce + nonceStateSeparator + additional state\r\n     * Default separator is ';' (encoded %3B).\r\n     * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\r\n     */\n\n    this.nonceStateSeparator = ';';\n    /**\r\n     * Set this to true to use HTTP BASIC auth for AJAX calls\r\n     */\n\n    this.useHttpBasicAuth = false;\n    /**\r\n     * The interceptors waits this time span if there is no token\r\n     */\n\n    this.waitForTokenInMsec = 0;\n    /**\r\n     * Code Flow is by defauld used together with PKCI which is also higly recommented.\r\n     * You can disbale it here by setting this flag to true.\r\n     * https://tools.ietf.org/html/rfc7636#section-1.1\r\n     */\n\n    this.disablePKCE = false;\n    /**\r\n     * Set this to true to preserve the requested route including query parameters after code flow login.\r\n     * This setting enables deep linking for the code flow.\r\n     */\n\n    this.preserveRequestedRoute = false;\n    /**\r\n     * This property allows you to override the method that is used to open the login url,\r\n     * allowing a way for implementations to specify their own method of routing to new\r\n     * urls.\r\n     */\n\n    this.openUri = uri => {\n      location.href = uri;\n    };\n\n    if (json) {\n      Object.assign(this, json);\n    }\n  }\n\n}\n/**\r\n * This custom encoder allows charactes like +, % and / to be used in passwords\r\n */\n\n\nclass WebHttpUrlEncodingCodec {\n  encodeKey(k) {\n    return encodeURIComponent(k);\n  }\n\n  encodeValue(v) {\n    return encodeURIComponent(v);\n  }\n\n  decodeKey(k) {\n    return decodeURIComponent(k);\n  }\n\n  decodeValue(v) {\n    return decodeURIComponent(v);\n  }\n\n}\n/**\r\n * Interface for Handlers that are hooked in to\r\n * validate tokens.\r\n */\n\n\nclass ValidationHandler {}\n/**\r\n * This abstract implementation of ValidationHandler already implements\r\n * the method validateAtHash. However, to make use of it,\r\n * you have to override the method calcHash.\r\n */\n\n\nclass AbstractValidationHandler {\n  /**\r\n   * Validates the at_hash in an id_token against the received access_token.\r\n   */\n  validateAtHash(params) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let hashAlg = _this.inferHashAlgorithm(params.idTokenHeader);\n\n      let tokenHash = yield _this.calcHash(params.accessToken, hashAlg); // sha256(accessToken, { asString: true });\n\n      let leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n      let atHash = base64UrlEncode(leftMostHalf);\n      let claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n\n      if (atHash !== claimsAtHash) {\n        console.error('exptected at_hash: ' + atHash);\n        console.error('actual at_hash: ' + claimsAtHash);\n      }\n\n      return atHash === claimsAtHash;\n    })();\n  }\n  /**\r\n   * Infers the name of the hash algorithm to use\r\n   * from the alg field of an id_token.\r\n   *\r\n   * @param jwtHeader the id_token's parsed header\r\n   */\n\n\n  inferHashAlgorithm(jwtHeader) {\n    let alg = jwtHeader['alg'];\n\n    if (!alg.match(/^.S[0-9]{3}$/)) {\n      throw new Error('Algorithm not supported: ' + alg);\n    }\n\n    return 'sha-' + alg.substr(2);\n  }\n\n}\n\nlet UrlHelperService = /*#__PURE__*/(() => {\n  class UrlHelperService {\n    getHashFragmentParams(customHashFragment) {\n      let hash = customHashFragment || window.location.hash;\n      hash = decodeURIComponent(hash);\n\n      if (hash.indexOf('#') !== 0) {\n        return {};\n      }\n\n      const questionMarkPosition = hash.indexOf('?');\n\n      if (questionMarkPosition > -1) {\n        hash = hash.substr(questionMarkPosition + 1);\n      } else {\n        hash = hash.substr(1);\n      }\n\n      return this.parseQueryString(hash);\n    }\n\n    parseQueryString(queryString) {\n      const data = {};\n      let pairs, pair, separatorIndex, escapedKey, escapedValue, key, value;\n\n      if (queryString === null) {\n        return data;\n      }\n\n      pairs = queryString.split('&');\n\n      for (let i = 0; i < pairs.length; i++) {\n        pair = pairs[i];\n        separatorIndex = pair.indexOf('=');\n\n        if (separatorIndex === -1) {\n          escapedKey = pair;\n          escapedValue = null;\n        } else {\n          escapedKey = pair.substr(0, separatorIndex);\n          escapedValue = pair.substr(separatorIndex + 1);\n        }\n\n        key = decodeURIComponent(escapedKey);\n        value = decodeURIComponent(escapedValue);\n\n        if (key.substr(0, 1) === '/') {\n          key = key.substr(1);\n        }\n\n        data[key] = value;\n      }\n\n      return data;\n    }\n\n  }\n\n  UrlHelperService.ɵfac = function UrlHelperService_Factory(t) {\n    return new (t || UrlHelperService)();\n  };\n\n  UrlHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlHelperService,\n    factory: UrlHelperService.ɵfac\n  });\n  return UrlHelperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\r\n *\r\n * @version 0.9.0\r\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\r\n * @copyright Chen, Yi-Cyuan 2014-2017\r\n * @license MIT\r\n */\n\n/*jslint bitwise: true */\n\n\nfunction factory() {\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n\n  if (root.JS_SHA256_NO_WINDOW) {\n    WINDOW = false;\n  }\n\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n\n  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  const HEX_CHARS = '0123456789abcdef'.split('');\n  const EXTRA = [-2147483648, 8388608, 32768, 128];\n  const SHIFT = [24, 16, 8, 0];\n  const K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n  const OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n  var blocks = [];\n\n  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (outputType, is224) {\n    return function (message) {\n      return new Sha256(is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function (is224) {\n    var method = createOutputMethod('hex', is224);\n\n    if (NODE_JS) {\n      method = nodeWrap(method, is224);\n    }\n\n    method.create = function () {\n      return new Sha256(is224);\n    };\n\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type, is224);\n    }\n\n    return method;\n  };\n\n  var nodeWrap = function (method, is224) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var algorithm = is224 ? 'sha224' : 'sha256';\n\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n\n      if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {\n        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n\n    return nodeMethod;\n  };\n\n  var createHmacOutputMethod = function (outputType, is224) {\n    return function (key, message) {\n      return new HmacSha256(key, is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createHmacMethod = function (is224) {\n    var method = createHmacOutputMethod('hex', is224);\n\n    method.create = function (key) {\n      return new HmacSha256(key, is224);\n    };\n\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type, is224);\n    }\n\n    return method;\n  };\n\n  function Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    if (is224) {\n      this.h0 = 0xc1059ed8;\n      this.h1 = 0x367cd507;\n      this.h2 = 0x3070dd17;\n      this.h3 = 0xf70e5939;\n      this.h4 = 0xffc00b31;\n      this.h5 = 0x68581511;\n      this.h6 = 0x64f98fa7;\n      this.h7 = 0xbefa4fa4;\n    } else {\n      // 256\n      this.h0 = 0x6a09e667;\n      this.h1 = 0xbb67ae85;\n      this.h2 = 0x3c6ef372;\n      this.h3 = 0xa54ff53a;\n      this.h4 = 0x510e527f;\n      this.h5 = 0x9b05688c;\n      this.h6 = 0x1f83d9ab;\n      this.h7 = 0x5be0cd19;\n    }\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n  }\n\n  Sha256.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n\n    var notString,\n        type = typeof message;\n\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n\n      notString = true;\n    }\n\n    var code,\n        index = 0,\n        i,\n        length = message.length,\n        blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);\n            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n\n    return this;\n  };\n\n  Sha256.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n\n    this.finalized = true;\n    var blocks = this.blocks,\n        i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha256.prototype.hash = function () {\n    var a = this.h0,\n        b = this.h1,\n        c = this.h2,\n        d = this.h3,\n        e = this.h4,\n        f = this.h5,\n        g = this.h6,\n        h = this.h7,\n        blocks = this.blocks,\n        j,\n        s0,\n        s1,\n        maj,\n        t1,\n        t2,\n        ch,\n        ab,\n        da,\n        cd,\n        bc;\n\n    for (j = 16; j < 64; ++j) {\n      // rightrotate\n      t1 = blocks[j - 15];\n      s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;\n      t1 = blocks[j - 2];\n      s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;\n      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;\n    }\n\n    bc = b & c;\n\n    for (j = 0; j < 64; j += 4) {\n      if (this.first) {\n        if (this.is224) {\n          ab = 300032;\n          t1 = blocks[0] - 1413257819;\n          h = t1 - 150054599 << 0;\n          d = t1 + 24177077 << 0;\n        } else {\n          ab = 704751109;\n          t1 = blocks[0] - 210244248;\n          h = t1 - 1521486534 << 0;\n          d = t1 + 143694565 << 0;\n        }\n\n        this.first = false;\n      } else {\n        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);\n        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);\n        ab = a & b;\n        maj = ab ^ a & c ^ bc;\n        ch = e & f ^ ~e & g;\n        t1 = h + s1 + ch + K[j] + blocks[j];\n        t2 = s0 + maj;\n        h = d + t1 << 0;\n        d = t1 + t2 << 0;\n      }\n\n      s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);\n      s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);\n      da = d & a;\n      maj = da ^ d & b ^ ab;\n      ch = h & e ^ ~h & f;\n      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];\n      t2 = s0 + maj;\n      g = c + t1 << 0;\n      c = t1 + t2 << 0;\n      s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);\n      s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);\n      cd = c & d;\n      maj = cd ^ c & a ^ da;\n      ch = g & h ^ ~g & e;\n      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];\n      t2 = s0 + maj;\n      f = b + t1 << 0;\n      b = t1 + t2 << 0;\n      s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);\n      s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);\n      bc = b & c;\n      maj = bc ^ b & d ^ cd;\n      ch = f & g ^ ~f & h;\n      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n      t2 = s0 + maj;\n      e = a + t1 << 0;\n      a = t1 + t2 << 0;\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n    this.h5 = this.h5 + f << 0;\n    this.h6 = this.h6 + g << 0;\n    this.h7 = this.h7 + h << 0;\n  };\n\n  Sha256.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0,\n        h1 = this.h1,\n        h2 = this.h2,\n        h3 = this.h3,\n        h4 = this.h4,\n        h5 = this.h5,\n        h6 = this.h6,\n        h7 = this.h7;\n    var hex = HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h4 >> 28 & 0x0F] + HEX_CHARS[h4 >> 24 & 0x0F] + HEX_CHARS[h4 >> 20 & 0x0F] + HEX_CHARS[h4 >> 16 & 0x0F] + HEX_CHARS[h4 >> 12 & 0x0F] + HEX_CHARS[h4 >> 8 & 0x0F] + HEX_CHARS[h4 >> 4 & 0x0F] + HEX_CHARS[h4 & 0x0F] + HEX_CHARS[h5 >> 28 & 0x0F] + HEX_CHARS[h5 >> 24 & 0x0F] + HEX_CHARS[h5 >> 20 & 0x0F] + HEX_CHARS[h5 >> 16 & 0x0F] + HEX_CHARS[h5 >> 12 & 0x0F] + HEX_CHARS[h5 >> 8 & 0x0F] + HEX_CHARS[h5 >> 4 & 0x0F] + HEX_CHARS[h5 & 0x0F] + HEX_CHARS[h6 >> 28 & 0x0F] + HEX_CHARS[h6 >> 24 & 0x0F] + HEX_CHARS[h6 >> 20 & 0x0F] + HEX_CHARS[h6 >> 16 & 0x0F] + HEX_CHARS[h6 >> 12 & 0x0F] + HEX_CHARS[h6 >> 8 & 0x0F] + HEX_CHARS[h6 >> 4 & 0x0F] + HEX_CHARS[h6 & 0x0F];\n\n    if (!this.is224) {\n      hex += HEX_CHARS[h7 >> 28 & 0x0F] + HEX_CHARS[h7 >> 24 & 0x0F] + HEX_CHARS[h7 >> 20 & 0x0F] + HEX_CHARS[h7 >> 16 & 0x0F] + HEX_CHARS[h7 >> 12 & 0x0F] + HEX_CHARS[h7 >> 8 & 0x0F] + HEX_CHARS[h7 >> 4 & 0x0F] + HEX_CHARS[h7 & 0x0F];\n    }\n\n    return hex;\n  };\n\n  Sha256.prototype.toString = Sha256.prototype.hex;\n\n  Sha256.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0,\n        h1 = this.h1,\n        h2 = this.h2,\n        h3 = this.h3,\n        h4 = this.h4,\n        h5 = this.h5,\n        h6 = this.h6,\n        h7 = this.h7;\n    var arr = [h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF];\n\n    if (!this.is224) {\n      arr.push(h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF);\n    }\n\n    return arr;\n  };\n\n  Sha256.prototype.array = Sha256.prototype.digest;\n\n  Sha256.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n\n    if (!this.is224) {\n      dataView.setUint32(28, this.h7);\n    }\n\n    return buffer;\n  };\n\n  function HmacSha256(key, is224, sharedMemory) {\n    var i,\n        type = typeof key;\n\n    if (type === 'string') {\n      var bytes = [],\n          length = key.length,\n          index = 0,\n          code;\n\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = 0xc0 | code >> 6;\n          bytes[index++] = 0x80 | code & 0x3f;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = 0xe0 | code >> 12;\n          bytes[index++] = 0x80 | code >> 6 & 0x3f;\n          bytes[index++] = 0x80 | code & 0x3f;\n        } else {\n          code = 0x10000 + ((code & 0x3ff) << 10 | key.charCodeAt(++i) & 0x3ff);\n          bytes[index++] = 0xf0 | code >> 18;\n          bytes[index++] = 0x80 | code >> 12 & 0x3f;\n          bytes[index++] = 0x80 | code >> 6 & 0x3f;\n          bytes[index++] = 0x80 | code & 0x3f;\n        }\n      }\n\n      key = bytes;\n    } else {\n      if (type === 'object') {\n        if (key === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {\n          key = new Uint8Array(key);\n        } else if (!Array.isArray(key)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n    }\n\n    if (key.length > 64) {\n      key = new Sha256(is224, true).update(key).array();\n    }\n\n    var oKeyPad = [],\n        iKeyPad = [];\n\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Sha256.call(this, is224, sharedMemory);\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n\n  HmacSha256.prototype = new Sha256();\n\n  HmacSha256.prototype.finalize = function () {\n    Sha256.prototype.finalize.call(this);\n\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Sha256.call(this, this.is224, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Sha256.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.sha256 = exports;\n  exports.sha224 = createMethod(true);\n  exports.sha256.hmac = createHmacMethod();\n  exports.sha224.hmac = createHmacMethod(true);\n  return exports;\n}\n\nconst sha256 = factory();\n/**\r\n * Abstraction for crypto algorithms\r\n */\n\nclass HashHandler {}\n\nfunction decodeUTF8(s) {\n  if (typeof s !== 'string') throw new TypeError('expected string');\n  var i,\n      d = s,\n      b = new Uint8Array(d.length);\n\n  for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);\n\n  return b;\n}\n\nfunction encodeUTF8(arr) {\n  var i,\n      s = [];\n\n  for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));\n\n  return s.join('');\n}\n\nlet DefaultHashHandler = /*#__PURE__*/(() => {\n  class DefaultHashHandler {\n    calcHash(valueToHash, algorithm) {\n      return _asyncToGenerator(function* () {\n        // const encoder = new TextEncoder();\n        // const hashArray = await window.crypto.subtle.digest(algorithm, data);\n        // const data = encoder.encode(valueToHash);\n        // const fhash = fsha256(valueToHash);\n        const candHash = encodeUTF8(fsha256(decodeUTF8(valueToHash))); // const hashArray = (sha256 as any).array(valueToHash);\n        // // const hashString = this.toHashString(hashArray);\n        // const hashString = this.toHashString2(hashArray);\n        // console.debug('hash orig - cand', candHash, hashString);\n        // alert(1);\n\n        return candHash;\n      })();\n    }\n\n    toHashString2(byteArray) {\n      let result = '';\n\n      for (let e of byteArray) {\n        result += String.fromCharCode(e);\n      }\n\n      return result;\n    }\n\n    toHashString(buffer) {\n      const byteArray = new Uint8Array(buffer);\n      let result = '';\n\n      for (let e of byteArray) {\n        result += String.fromCharCode(e);\n      }\n\n      return result;\n    }\n\n  }\n\n  DefaultHashHandler.ɵfac = function DefaultHashHandler_Factory(t) {\n    return new (t || DefaultHashHandler)();\n  };\n\n  DefaultHashHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultHashHandler,\n    factory: DefaultHashHandler.ɵfac\n  });\n  return DefaultHashHandler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Service for logging in and logging out with\r\n * OIDC and OAuth2. Supports implicit flow and\r\n * password flow.\r\n */\n\n\nlet OAuthService = /*#__PURE__*/(() => {\n  class OAuthService extends AuthConfig {\n    constructor(ngZone, http, storage, tokenValidationHandler, config, urlHelper, logger, crypto, document, dateTimeService) {\n      super();\n      this.ngZone = ngZone;\n      this.http = http;\n      this.config = config;\n      this.urlHelper = urlHelper;\n      this.logger = logger;\n      this.crypto = crypto;\n      this.dateTimeService = dateTimeService;\n      /**\r\n       * @internal\r\n       * Deprecated:  use property events instead\r\n       */\n\n      this.discoveryDocumentLoaded = false;\n      /**\r\n       * The received (passed around) state, when logging\r\n       * in with implicit flow.\r\n       */\n\n      this.state = '';\n      this.eventsSubject = new Subject();\n      this.discoveryDocumentLoadedSubject = new Subject();\n      this.grantTypesSupported = [];\n      this.inImplicitFlow = false;\n      this.saveNoncesInLocalStorage = false;\n      this.debug('angular-oauth2-oidc v10'); // See https://github.com/manfredsteyer/angular-oauth2-oidc/issues/773 for why this is needed\n\n      this.document = document;\n\n      if (!config) {\n        config = {};\n      }\n\n      this.discoveryDocumentLoaded$ = this.discoveryDocumentLoadedSubject.asObservable();\n      this.events = this.eventsSubject.asObservable();\n\n      if (tokenValidationHandler) {\n        this.tokenValidationHandler = tokenValidationHandler;\n      }\n\n      if (config) {\n        this.configure(config);\n      }\n\n      try {\n        if (storage) {\n          this.setStorage(storage);\n        } else if (typeof sessionStorage !== 'undefined') {\n          this.setStorage(sessionStorage);\n        }\n      } catch (e) {\n        console.error('No OAuthStorage provided and cannot access default (sessionStorage).' + 'Consider providing a custom OAuthStorage implementation in your module.', e);\n      } // in IE, sessionStorage does not always survive a redirect\n\n\n      if (this.checkLocalStorageAccessable()) {\n        const ua = window?.navigator?.userAgent;\n        const msie = ua?.includes('MSIE ') || ua?.includes('Trident');\n\n        if (msie) {\n          this.saveNoncesInLocalStorage = true;\n        }\n      }\n\n      this.setupRefreshTimer();\n    }\n\n    checkLocalStorageAccessable() {\n      if (typeof window === 'undefined') return false;\n      const test = 'test';\n\n      try {\n        if (typeof window['localStorage'] === 'undefined') return false;\n        localStorage.setItem(test, test);\n        localStorage.removeItem(test);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n    /**\r\n     * Use this method to configure the service\r\n     * @param config the configuration\r\n     */\n\n\n    configure(config) {\n      // For the sake of downward compatibility with\n      // original configuration API\n      Object.assign(this, new AuthConfig(), config);\n      this.config = Object.assign({}, new AuthConfig(), config);\n\n      if (this.sessionChecksEnabled) {\n        this.setupSessionCheck();\n      }\n\n      this.configChanged();\n    }\n\n    configChanged() {\n      this.setupRefreshTimer();\n    }\n\n    restartSessionChecksIfStillLoggedIn() {\n      if (this.hasValidIdToken()) {\n        this.initSessionCheck();\n      }\n    }\n\n    restartRefreshTimerIfStillLoggedIn() {\n      this.setupExpirationTimers();\n    }\n\n    setupSessionCheck() {\n      this.events.pipe(filter(e => e.type === 'token_received')).subscribe(e => {\n        this.initSessionCheck();\n      });\n    }\n    /**\r\n     * Will setup up silent refreshing for when the token is\r\n     * about to expire. When the user is logged out via this.logOut method, the\r\n     * silent refreshing will pause and not refresh the tokens until the user is\r\n     * logged back in via receiving a new token.\r\n     * @param params Additional parameter to pass\r\n     * @param listenTo Setup automatic refresh of a specific token type\r\n     */\n\n\n    setupAutomaticSilentRefresh(params = {}, listenTo, noPrompt = true) {\n      let shouldRunSilentRefresh = true;\n      this.clearAutomaticRefreshTimer();\n      this.automaticRefreshSubscription = this.events.pipe(tap(e => {\n        if (e.type === 'token_received') {\n          shouldRunSilentRefresh = true;\n        } else if (e.type === 'logout') {\n          shouldRunSilentRefresh = false;\n        }\n      }), filter(e => e.type === 'token_expires' && (listenTo == null || listenTo === 'any' || e.info === listenTo)), debounceTime(1000)).subscribe(_ => {\n        if (shouldRunSilentRefresh) {\n          // this.silentRefresh(params, noPrompt).catch(_ => {\n          this.refreshInternal(params, noPrompt).catch(_ => {\n            this.debug('Automatic silent refresh did not work');\n          });\n        }\n      });\n      this.restartRefreshTimerIfStillLoggedIn();\n    }\n\n    refreshInternal(params, noPrompt) {\n      if (!this.useSilentRefresh && this.responseType === 'code') {\n        return this.refreshToken();\n      } else {\n        return this.silentRefresh(params, noPrompt);\n      }\n    }\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocument(...)` and\r\n     * directly chains using the `then(...)` part of the promise to call\r\n     * the `tryLogin(...)` method.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\n\n\n    loadDiscoveryDocumentAndTryLogin(options = null) {\n      return this.loadDiscoveryDocument().then(doc => {\n        return this.tryLogin(options);\n      });\n    }\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\r\n     * and if then chains to `initLoginFlow()`, but only if there is no valid\r\n     * IdToken or no valid AccessToken.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\n\n\n    loadDiscoveryDocumentAndLogin(options = null) {\n      options = options || {};\n      return this.loadDiscoveryDocumentAndTryLogin(options).then(_ => {\n        if (!this.hasValidIdToken() || !this.hasValidAccessToken()) {\n          const state = typeof options.state === 'string' ? options.state : '';\n          this.initLoginFlow(state);\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n\n    debug(...args) {\n      if (this.showDebugInformation) {\n        this.logger.debug.apply(this.logger, args);\n      }\n    }\n\n    validateUrlFromDiscoveryDocument(url) {\n      const errors = [];\n      const httpsCheck = this.validateUrlForHttps(url);\n      const issuerCheck = this.validateUrlAgainstIssuer(url);\n\n      if (!httpsCheck) {\n        errors.push('https for all urls required. Also for urls received by discovery.');\n      }\n\n      if (!issuerCheck) {\n        errors.push('Every url in discovery document has to start with the issuer url.' + 'Also see property strictDiscoveryDocumentValidation.');\n      }\n\n      return errors;\n    }\n\n    validateUrlForHttps(url) {\n      if (!url) {\n        return true;\n      }\n\n      const lcUrl = url.toLowerCase();\n\n      if (this.requireHttps === false) {\n        return true;\n      }\n\n      if ((lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) || lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) && this.requireHttps === 'remoteOnly') {\n        return true;\n      }\n\n      return lcUrl.startsWith('https://');\n    }\n\n    assertUrlNotNullAndCorrectProtocol(url, description) {\n      if (!url) {\n        throw new Error(`'${description}' should not be null`);\n      }\n\n      if (!this.validateUrlForHttps(url)) {\n        throw new Error(`'${description}' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).`);\n      }\n    }\n\n    validateUrlAgainstIssuer(url) {\n      if (!this.strictDiscoveryDocumentValidation) {\n        return true;\n      }\n\n      if (!url) {\n        return true;\n      }\n\n      return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n    }\n\n    setupRefreshTimer() {\n      if (typeof window === 'undefined') {\n        this.debug('timer not supported on this plattform');\n        return;\n      }\n\n      if (this.hasValidIdToken() || this.hasValidAccessToken()) {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n        this.setupExpirationTimers();\n      }\n\n      if (this.tokenReceivedSubscription) this.tokenReceivedSubscription.unsubscribe();\n      this.tokenReceivedSubscription = this.events.pipe(filter(e => e.type === 'token_received')).subscribe(_ => {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n        this.setupExpirationTimers();\n      });\n    }\n\n    setupExpirationTimers() {\n      if (this.hasValidAccessToken()) {\n        this.setupAccessTokenTimer();\n      }\n\n      if (this.hasValidIdToken()) {\n        this.setupIdTokenTimer();\n      }\n    }\n\n    setupAccessTokenTimer() {\n      const expiration = this.getAccessTokenExpiration();\n      const storedAt = this.getAccessTokenStoredAt();\n      const timeout = this.calcTimeout(storedAt, expiration);\n      this.ngZone.runOutsideAngular(() => {\n        this.accessTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'access_token')).pipe(delay(timeout)).subscribe(e => {\n          this.ngZone.run(() => {\n            this.eventsSubject.next(e);\n          });\n        });\n      });\n    }\n\n    setupIdTokenTimer() {\n      const expiration = this.getIdTokenExpiration();\n      const storedAt = this.getIdTokenStoredAt();\n      const timeout = this.calcTimeout(storedAt, expiration);\n      this.ngZone.runOutsideAngular(() => {\n        this.idTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'id_token')).pipe(delay(timeout)).subscribe(e => {\n          this.ngZone.run(() => {\n            this.eventsSubject.next(e);\n          });\n        });\n      });\n    }\n    /**\r\n     * Stops timers for automatic refresh.\r\n     * To restart it, call setupAutomaticSilentRefresh again.\r\n     */\n\n\n    stopAutomaticRefresh() {\n      this.clearAccessTokenTimer();\n      this.clearIdTokenTimer();\n      this.clearAutomaticRefreshTimer();\n    }\n\n    clearAccessTokenTimer() {\n      if (this.accessTokenTimeoutSubscription) {\n        this.accessTokenTimeoutSubscription.unsubscribe();\n      }\n    }\n\n    clearIdTokenTimer() {\n      if (this.idTokenTimeoutSubscription) {\n        this.idTokenTimeoutSubscription.unsubscribe();\n      }\n    }\n\n    clearAutomaticRefreshTimer() {\n      if (this.automaticRefreshSubscription) {\n        this.automaticRefreshSubscription.unsubscribe();\n      }\n    }\n\n    calcTimeout(storedAt, expiration) {\n      const now = this.dateTimeService.now();\n      const delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n      return Math.max(0, delta);\n    }\n    /**\r\n     * DEPRECATED. Use a provider for OAuthStorage instead:\r\n     *\r\n     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\r\n     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\r\n     * Sets a custom storage used to store the received\r\n     * tokens on client side. By default, the browser's\r\n     * sessionStorage is used.\r\n     * @ignore\r\n     *\r\n     * @param storage\r\n     */\n\n\n    setStorage(storage) {\n      this._storage = storage;\n      this.configChanged();\n    }\n    /**\r\n     * Loads the discovery document to configure most\r\n     * properties of this service. The url of the discovery\r\n     * document is infered from the issuer's url according\r\n     * to the OpenId Connect spec. To use another url you\r\n     * can pass it to to optional parameter fullUrl.\r\n     *\r\n     * @param fullUrl\r\n     */\n\n\n    loadDiscoveryDocument(fullUrl = null) {\n      return new Promise((resolve, reject) => {\n        if (!fullUrl) {\n          fullUrl = this.issuer || '';\n\n          if (!fullUrl.endsWith('/')) {\n            fullUrl += '/';\n          }\n\n          fullUrl += '.well-known/openid-configuration';\n        }\n\n        if (!this.validateUrlForHttps(fullUrl)) {\n          reject(\"issuer  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n          return;\n        }\n\n        this.http.get(fullUrl).subscribe(doc => {\n          if (!this.validateDiscoveryDocument(doc)) {\n            this.eventsSubject.next(new OAuthErrorEvent('discovery_document_validation_error', null));\n            reject('discovery_document_validation_error');\n            return;\n          }\n\n          this.loginUrl = doc.authorization_endpoint;\n          this.logoutUrl = doc.end_session_endpoint || this.logoutUrl;\n          this.grantTypesSupported = doc.grant_types_supported;\n          this.issuer = doc.issuer;\n          this.tokenEndpoint = doc.token_endpoint;\n          this.userinfoEndpoint = doc.userinfo_endpoint || this.userinfoEndpoint;\n          this.jwksUri = doc.jwks_uri;\n          this.sessionCheckIFrameUrl = doc.check_session_iframe || this.sessionCheckIFrameUrl;\n          this.discoveryDocumentLoaded = true;\n          this.discoveryDocumentLoadedSubject.next(doc);\n          this.revocationEndpoint = doc.revocation_endpoint || this.revocationEndpoint;\n\n          if (this.sessionChecksEnabled) {\n            this.restartSessionChecksIfStillLoggedIn();\n          }\n\n          this.loadJwks().then(jwks => {\n            const result = {\n              discoveryDocument: doc,\n              jwks: jwks\n            };\n            const event = new OAuthSuccessEvent('discovery_document_loaded', result);\n            this.eventsSubject.next(event);\n            resolve(event);\n            return;\n          }).catch(err => {\n            this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n            reject(err);\n            return;\n          });\n        }, err => {\n          this.logger.error('error loading discovery document', err);\n          this.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n          reject(err);\n        });\n      });\n    }\n\n    loadJwks() {\n      return new Promise((resolve, reject) => {\n        if (this.jwksUri) {\n          this.http.get(this.jwksUri).subscribe(jwks => {\n            this.jwks = jwks;\n            this.eventsSubject.next(new OAuthSuccessEvent('discovery_document_loaded'));\n            resolve(jwks);\n          }, err => {\n            this.logger.error('error loading jwks', err);\n            this.eventsSubject.next(new OAuthErrorEvent('jwks_load_error', err));\n            reject(err);\n          });\n        } else {\n          resolve(null);\n        }\n      });\n    }\n\n    validateDiscoveryDocument(doc) {\n      let errors;\n\n      if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n        this.logger.error('invalid issuer in discovery document', 'expected: ' + this.issuer, 'current: ' + doc.issuer);\n        return false;\n      }\n\n      errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n\n      if (errors.length > 0) {\n        this.logger.error('error validating authorization_endpoint in discovery document', errors);\n        return false;\n      }\n\n      errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n\n      if (errors.length > 0) {\n        this.logger.error('error validating end_session_endpoint in discovery document', errors);\n        return false;\n      }\n\n      errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n\n      if (errors.length > 0) {\n        this.logger.error('error validating token_endpoint in discovery document', errors);\n      }\n\n      errors = this.validateUrlFromDiscoveryDocument(doc.revocation_endpoint);\n\n      if (errors.length > 0) {\n        this.logger.error('error validating revocation_endpoint in discovery document', errors);\n      }\n\n      errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n\n      if (errors.length > 0) {\n        this.logger.error('error validating userinfo_endpoint in discovery document', errors);\n        return false;\n      }\n\n      errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n\n      if (errors.length > 0) {\n        this.logger.error('error validating jwks_uri in discovery document', errors);\n        return false;\n      }\n\n      if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n        this.logger.warn('sessionChecksEnabled is activated but discovery document' + ' does not contain a check_session_iframe field');\n      }\n\n      return true;\n    }\n    /**\r\n     * Uses password flow to exchange userName and password for an\r\n     * access_token. After receiving the access_token, this method\r\n     * uses it to query the userinfo endpoint in order to get information\r\n     * about the user in question.\r\n     *\r\n     * When using this, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation\r\n     * fail.\r\n     *\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\n\n\n    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName, password, headers = new HttpHeaders()) {\n      return this.fetchTokenUsingPasswordFlow(userName, password, headers).then(() => this.loadUserProfile());\n    }\n    /**\r\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n     *\r\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation fail.\r\n     */\n\n\n    loadUserProfile() {\n      if (!this.hasValidAccessToken()) {\n        throw new Error('Can not load User Profile without access_token');\n      }\n\n      if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n        throw new Error(\"userinfoEndpoint must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n\n      return new Promise((resolve, reject) => {\n        const headers = new HttpHeaders().set('Authorization', 'Bearer ' + this.getAccessToken());\n        this.http.get(this.userinfoEndpoint, {\n          headers,\n          observe: 'response',\n          responseType: 'text'\n        }).subscribe(response => {\n          this.debug('userinfo received', JSON.stringify(response));\n\n          if (response.headers.get('content-type').startsWith('application/json')) {\n            let info = JSON.parse(response.body);\n            const existingClaims = this.getIdentityClaims() || {};\n\n            if (!this.skipSubjectCheck) {\n              if (this.oidc && (!existingClaims['sub'] || info.sub !== existingClaims['sub'])) {\n                const err = 'if property oidc is true, the received user-id (sub) has to be the user-id ' + 'of the user that has logged in with oidc.\\n' + 'if you are not using oidc but just oauth2 password flow set oidc to false';\n                reject(err);\n                return;\n              }\n            }\n\n            info = Object.assign({}, existingClaims, info);\n\n            this._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n\n            this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n            resolve({\n              info\n            });\n          } else {\n            this.debug('userinfo is not JSON, treating it as JWE/JWS');\n            this.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n            resolve(JSON.parse(response.body));\n          }\n        }, err => {\n          this.logger.error('error loading user info', err);\n          this.eventsSubject.next(new OAuthErrorEvent('user_profile_load_error', err));\n          reject(err);\n        });\n      });\n    }\n    /**\r\n     * Uses password flow to exchange userName and password for an access_token.\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\n\n\n    fetchTokenUsingPasswordFlow(userName, password, headers = new HttpHeaders()) {\n      const parameters = {\n        username: userName,\n        password: password\n      };\n      return this.fetchTokenUsingGrant('password', parameters, headers);\n    }\n    /**\r\n     * Uses a custom grant type to retrieve tokens.\r\n     * @param grantType Grant type.\r\n     * @param parameters Parameters to pass.\r\n     * @param headers Optional additional HTTP headers.\r\n     */\n\n\n    fetchTokenUsingGrant(grantType, parameters, headers = new HttpHeaders()) {\n      this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n      /**\r\n       * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\r\n       * serialize and parse URL parameter keys and values.\r\n       *\r\n       * @stable\r\n       */\n\n      let params = new HttpParams({\n        encoder: new WebHttpUrlEncodingCodec()\n      }).set('grant_type', grantType).set('scope', this.scope);\n\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      } // set explicit parameters last, to allow overwriting\n\n\n      for (const key of Object.keys(parameters)) {\n        params = params.set(key, parameters[key]);\n      }\n\n      headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n      return new Promise((resolve, reject) => {\n        this.http.post(this.tokenEndpoint, params, {\n          headers\n        }).subscribe(tokenResponse => {\n          this.debug('tokenResponse', tokenResponse);\n          this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n\n          if (this.oidc && tokenResponse.id_token) {\n            this.processIdToken(tokenResponse.id_token, tokenResponse.access_token).then(result => {\n              this.storeIdToken(result);\n              resolve(tokenResponse);\n            });\n          }\n\n          this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n          resolve(tokenResponse);\n        }, err => {\n          this.logger.error('Error performing ${grantType} flow', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n          reject(err);\n        });\n      });\n    }\n    /**\r\n     * Refreshes the token using a refresh_token.\r\n     * This does not work for implicit flow, b/c\r\n     * there is no refresh_token in this flow.\r\n     * A solution for this is provided by the\r\n     * method silentRefresh.\r\n     */\n\n\n    refreshToken() {\n      this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n      return new Promise((resolve, reject) => {\n        let params = new HttpParams({\n          encoder: new WebHttpUrlEncodingCodec()\n        }).set('grant_type', 'refresh_token').set('scope', this.scope).set('refresh_token', this._storage.getItem('refresh_token'));\n        let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n        if (this.useHttpBasicAuth) {\n          const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n          headers = headers.set('Authorization', 'Basic ' + header);\n        }\n\n        if (!this.useHttpBasicAuth) {\n          params = params.set('client_id', this.clientId);\n        }\n\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n          params = params.set('client_secret', this.dummyClientSecret);\n        }\n\n        if (this.customQueryParams) {\n          for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n            params = params.set(key, this.customQueryParams[key]);\n          }\n        }\n\n        this.http.post(this.tokenEndpoint, params, {\n          headers\n        }).pipe(switchMap(tokenResponse => {\n          if (tokenResponse.id_token) {\n            return from(this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true)).pipe(tap(result => this.storeIdToken(result)), map(_ => tokenResponse));\n          } else {\n            return of(tokenResponse);\n          }\n        })).subscribe(tokenResponse => {\n          this.debug('refresh tokenResponse', tokenResponse);\n          this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n          this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n          this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n          resolve(tokenResponse);\n        }, err => {\n          this.logger.error('Error refreshing token', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n          reject(err);\n        });\n      });\n    }\n\n    removeSilentRefreshEventListener() {\n      if (this.silentRefreshPostMessageEventListener) {\n        window.removeEventListener('message', this.silentRefreshPostMessageEventListener);\n        this.silentRefreshPostMessageEventListener = null;\n      }\n    }\n\n    setupSilentRefreshEventListener() {\n      this.removeSilentRefreshEventListener();\n\n      this.silentRefreshPostMessageEventListener = e => {\n        const message = this.processMessageEventMessage(e);\n        this.tryLogin({\n          customHashFragment: message,\n          preventClearHashAfterLogin: true,\n          customRedirectUri: this.silentRefreshRedirectUri || this.redirectUri\n        }).catch(err => this.debug('tryLogin during silent refresh failed', err));\n      };\n\n      window.addEventListener('message', this.silentRefreshPostMessageEventListener);\n    }\n    /**\r\n     * Performs a silent refresh for implicit flow.\r\n     * Use this method to get new tokens when/before\r\n     * the existing tokens expire.\r\n     */\n\n\n    silentRefresh(params = {}, noPrompt = true) {\n      const claims = this.getIdentityClaims() || {};\n\n      if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n        params['id_token_hint'] = this.getIdToken();\n      }\n\n      if (!this.validateUrlForHttps(this.loginUrl)) {\n        throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n\n      if (typeof this.document === 'undefined') {\n        throw new Error('silent refresh is not supported on this platform');\n      }\n\n      const existingIframe = this.document.getElementById(this.silentRefreshIFrameName);\n\n      if (existingIframe) {\n        this.document.body.removeChild(existingIframe);\n      }\n\n      this.silentRefreshSubject = claims['sub'];\n      const iframe = this.document.createElement('iframe');\n      iframe.id = this.silentRefreshIFrameName;\n      this.setupSilentRefreshEventListener();\n      const redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n      this.createLoginUrl(null, null, redirectUri, noPrompt, params).then(url => {\n        iframe.setAttribute('src', url);\n\n        if (!this.silentRefreshShowIFrame) {\n          iframe.style['display'] = 'none';\n        }\n\n        this.document.body.appendChild(iframe);\n      });\n      const errors = this.events.pipe(filter(e => e instanceof OAuthErrorEvent), first());\n      const success = this.events.pipe(filter(e => e.type === 'token_received'), first());\n      const timeout = of(new OAuthErrorEvent('silent_refresh_timeout', null)).pipe(delay(this.silentRefreshTimeout));\n      return race([errors, success, timeout]).pipe(map(e => {\n        if (e instanceof OAuthErrorEvent) {\n          if (e.type === 'silent_refresh_timeout') {\n            this.eventsSubject.next(e);\n          } else {\n            e = new OAuthErrorEvent('silent_refresh_error', e);\n            this.eventsSubject.next(e);\n          }\n\n          throw e;\n        } else if (e.type === 'token_received') {\n          e = new OAuthSuccessEvent('silently_refreshed');\n          this.eventsSubject.next(e);\n        }\n\n        return e;\n      })).toPromise();\n    }\n    /**\r\n     * This method exists for backwards compatibility.\r\n     * {@link OAuthService#initLoginFlowInPopup} handles both code\r\n     * and implicit flows.\r\n     */\n\n\n    initImplicitFlowInPopup(options) {\n      return this.initLoginFlowInPopup(options);\n    }\n\n    initLoginFlowInPopup(options) {\n      options = options || {};\n      return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\n        display: 'popup'\n      }).then(url => {\n        return new Promise((resolve, reject) => {\n          /**\r\n           * Error handling section\r\n           */\n          const checkForPopupClosedInterval = 500;\n          let windowRef = null; // If we got no window reference we open a window\n          // else we are using the window already opened\n\n          if (!options.windowRef) {\n            windowRef = window.open(url, 'ngx-oauth2-oidc-login', this.calculatePopupFeatures(options));\n          } else if (options.windowRef && !options.windowRef.closed) {\n            windowRef = options.windowRef;\n            windowRef.location.href = url;\n          }\n\n          let checkForPopupClosedTimer;\n\n          const tryLogin = hash => {\n            this.tryLogin({\n              customHashFragment: hash,\n              preventClearHashAfterLogin: true,\n              customRedirectUri: this.silentRefreshRedirectUri\n            }).then(() => {\n              cleanup();\n              resolve(true);\n            }, err => {\n              cleanup();\n              reject(err);\n            });\n          };\n\n          const checkForPopupClosed = () => {\n            if (!windowRef || windowRef.closed) {\n              cleanup();\n              reject(new OAuthErrorEvent('popup_closed', {}));\n            }\n          };\n\n          if (!windowRef) {\n            reject(new OAuthErrorEvent('popup_blocked', {}));\n          } else {\n            checkForPopupClosedTimer = window.setInterval(checkForPopupClosed, checkForPopupClosedInterval);\n          }\n\n          const cleanup = () => {\n            window.clearInterval(checkForPopupClosedTimer);\n            window.removeEventListener('storage', storageListener);\n            window.removeEventListener('message', listener);\n\n            if (windowRef !== null) {\n              windowRef.close();\n            }\n\n            windowRef = null;\n          };\n\n          const listener = e => {\n            const message = this.processMessageEventMessage(e);\n\n            if (message && message !== null) {\n              window.removeEventListener('storage', storageListener);\n              tryLogin(message);\n            } else {\n              console.log('false event firing');\n            }\n          };\n\n          const storageListener = event => {\n            if (event.key === 'auth_hash') {\n              window.removeEventListener('message', listener);\n              tryLogin(event.newValue);\n            }\n          };\n\n          window.addEventListener('message', listener);\n          window.addEventListener('storage', storageListener);\n        });\n      });\n    }\n\n    calculatePopupFeatures(options) {\n      // Specify an static height and width and calculate centered position\n      const height = options.height || 470;\n      const width = options.width || 500;\n      const left = window.screenLeft + (window.outerWidth - width) / 2;\n      const top = window.screenTop + (window.outerHeight - height) / 2;\n      return `location=no,toolbar=no,width=${width},height=${height},top=${top},left=${left}`;\n    }\n\n    processMessageEventMessage(e) {\n      let expectedPrefix = '#';\n\n      if (this.silentRefreshMessagePrefix) {\n        expectedPrefix += this.silentRefreshMessagePrefix;\n      }\n\n      if (!e || !e.data || typeof e.data !== 'string') {\n        return;\n      }\n\n      const prefixedMessage = e.data;\n\n      if (!prefixedMessage.startsWith(expectedPrefix)) {\n        return;\n      }\n\n      return '#' + prefixedMessage.substr(expectedPrefix.length);\n    }\n\n    canPerformSessionCheck() {\n      if (!this.sessionChecksEnabled) {\n        return false;\n      }\n\n      if (!this.sessionCheckIFrameUrl) {\n        console.warn('sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl');\n        return false;\n      }\n\n      const sessionState = this.getSessionState();\n\n      if (!sessionState) {\n        console.warn('sessionChecksEnabled is activated but there is no session_state');\n        return false;\n      }\n\n      if (typeof this.document === 'undefined') {\n        return false;\n      }\n\n      return true;\n    }\n\n    setupSessionCheckEventListener() {\n      this.removeSessionCheckEventListener();\n\n      this.sessionCheckEventListener = e => {\n        const origin = e.origin.toLowerCase();\n        const issuer = this.issuer.toLowerCase();\n        this.debug('sessionCheckEventListener');\n\n        if (!issuer.startsWith(origin)) {\n          this.debug('sessionCheckEventListener', 'wrong origin', origin, 'expected', issuer, 'event', e);\n          return;\n        } // only run in Angular zone if it is 'changed' or 'error'\n\n\n        switch (e.data) {\n          case 'unchanged':\n            this.ngZone.run(() => {\n              this.handleSessionUnchanged();\n            });\n            break;\n\n          case 'changed':\n            this.ngZone.run(() => {\n              this.handleSessionChange();\n            });\n            break;\n\n          case 'error':\n            this.ngZone.run(() => {\n              this.handleSessionError();\n            });\n            break;\n        }\n\n        this.debug('got info from session check inframe', e);\n      }; // prevent Angular from refreshing the view on every message (runs in intervals)\n\n\n      this.ngZone.runOutsideAngular(() => {\n        window.addEventListener('message', this.sessionCheckEventListener);\n      });\n    }\n\n    handleSessionUnchanged() {\n      this.debug('session check', 'session unchanged');\n      this.eventsSubject.next(new OAuthInfoEvent('session_unchanged'));\n    }\n\n    handleSessionChange() {\n      this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n      this.stopSessionCheckTimer();\n\n      if (!this.useSilentRefresh && this.responseType === 'code') {\n        this.refreshToken().then(_ => {\n          this.debug('token refresh after session change worked');\n        }).catch(_ => {\n          this.debug('token refresh did not work after session changed');\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n          this.logOut(true);\n        });\n      } else if (this.silentRefreshRedirectUri) {\n        this.silentRefresh().catch(_ => this.debug('silent refresh failed after session changed'));\n        this.waitForSilentRefreshAfterSessionChange();\n      } else {\n        this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n        this.logOut(true);\n      }\n    }\n\n    waitForSilentRefreshAfterSessionChange() {\n      this.events.pipe(filter(e => e.type === 'silently_refreshed' || e.type === 'silent_refresh_timeout' || e.type === 'silent_refresh_error'), first()).subscribe(e => {\n        if (e.type !== 'silently_refreshed') {\n          this.debug('silent refresh did not work after session changed');\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n          this.logOut(true);\n        }\n      });\n    }\n\n    handleSessionError() {\n      this.stopSessionCheckTimer();\n      this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n    }\n\n    removeSessionCheckEventListener() {\n      if (this.sessionCheckEventListener) {\n        window.removeEventListener('message', this.sessionCheckEventListener);\n        this.sessionCheckEventListener = null;\n      }\n    }\n\n    initSessionCheck() {\n      if (!this.canPerformSessionCheck()) {\n        return;\n      }\n\n      const existingIframe = this.document.getElementById(this.sessionCheckIFrameName);\n\n      if (existingIframe) {\n        this.document.body.removeChild(existingIframe);\n      }\n\n      const iframe = this.document.createElement('iframe');\n      iframe.id = this.sessionCheckIFrameName;\n      this.setupSessionCheckEventListener();\n      const url = this.sessionCheckIFrameUrl;\n      iframe.setAttribute('src', url);\n      iframe.style.display = 'none';\n      this.document.body.appendChild(iframe);\n      this.startSessionCheckTimer();\n    }\n\n    startSessionCheckTimer() {\n      this.stopSessionCheckTimer();\n      this.ngZone.runOutsideAngular(() => {\n        this.sessionCheckTimer = setInterval(this.checkSession.bind(this), this.sessionCheckIntervall);\n      });\n    }\n\n    stopSessionCheckTimer() {\n      if (this.sessionCheckTimer) {\n        clearInterval(this.sessionCheckTimer);\n        this.sessionCheckTimer = null;\n      }\n    }\n\n    checkSession() {\n      const iframe = this.document.getElementById(this.sessionCheckIFrameName);\n\n      if (!iframe) {\n        this.logger.warn('checkSession did not find iframe', this.sessionCheckIFrameName);\n      }\n\n      const sessionState = this.getSessionState();\n\n      if (!sessionState) {\n        this.stopSessionCheckTimer();\n      }\n\n      const message = this.clientId + ' ' + sessionState;\n      iframe.contentWindow.postMessage(message, this.issuer);\n    }\n\n    createLoginUrl(state = '', loginHint = '', customRedirectUri = '', noPrompt = false, params = {}) {\n      var _this2 = this;\n\n      return _asyncToGenerator(function* () {\n        const that = _this2;\n        let redirectUri;\n\n        if (customRedirectUri) {\n          redirectUri = customRedirectUri;\n        } else {\n          redirectUri = _this2.redirectUri;\n        }\n\n        const nonce = yield _this2.createAndSaveNonce();\n\n        if (state) {\n          state = nonce + _this2.config.nonceStateSeparator + encodeURIComponent(state);\n        } else {\n          state = nonce;\n        }\n\n        if (!_this2.requestAccessToken && !_this2.oidc) {\n          throw new Error('Either requestAccessToken or oidc or both must be true');\n        }\n\n        if (_this2.config.responseType) {\n          _this2.responseType = _this2.config.responseType;\n        } else {\n          if (_this2.oidc && _this2.requestAccessToken) {\n            _this2.responseType = 'id_token token';\n          } else if (_this2.oidc && !_this2.requestAccessToken) {\n            _this2.responseType = 'id_token';\n          } else {\n            _this2.responseType = 'token';\n          }\n        }\n\n        const seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n        let scope = that.scope;\n\n        if (_this2.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n          scope = 'openid ' + scope;\n        }\n\n        let url = that.loginUrl + seperationChar + 'response_type=' + encodeURIComponent(that.responseType) + '&client_id=' + encodeURIComponent(that.clientId) + '&state=' + encodeURIComponent(state) + '&redirect_uri=' + encodeURIComponent(redirectUri) + '&scope=' + encodeURIComponent(scope);\n\n        if (_this2.responseType.includes('code') && !_this2.disablePKCE) {\n          const [challenge, verifier] = yield _this2.createChallangeVerifierPairForPKCE();\n\n          if (_this2.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n            localStorage.setItem('PKCE_verifier', verifier);\n          } else {\n            _this2._storage.setItem('PKCE_verifier', verifier);\n          }\n\n          url += '&code_challenge=' + challenge;\n          url += '&code_challenge_method=S256';\n        }\n\n        if (loginHint) {\n          url += '&login_hint=' + encodeURIComponent(loginHint);\n        }\n\n        if (that.resource) {\n          url += '&resource=' + encodeURIComponent(that.resource);\n        }\n\n        if (that.oidc) {\n          url += '&nonce=' + encodeURIComponent(nonce);\n        }\n\n        if (noPrompt) {\n          url += '&prompt=none';\n        }\n\n        for (const key of Object.keys(params)) {\n          url += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n        }\n\n        if (_this2.customQueryParams) {\n          for (const key of Object.getOwnPropertyNames(_this2.customQueryParams)) {\n            url += '&' + key + '=' + encodeURIComponent(_this2.customQueryParams[key]);\n          }\n        }\n\n        return url;\n      })();\n    }\n\n    initImplicitFlowInternal(additionalState = '', params = '') {\n      if (this.inImplicitFlow) {\n        return;\n      }\n\n      this.inImplicitFlow = true;\n\n      if (!this.validateUrlForHttps(this.loginUrl)) {\n        throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n\n      let addParams = {};\n      let loginHint = null;\n\n      if (typeof params === 'string') {\n        loginHint = params;\n      } else if (typeof params === 'object') {\n        addParams = params;\n      }\n\n      this.createLoginUrl(additionalState, loginHint, null, false, addParams).then(this.config.openUri).catch(error => {\n        console.error('Error in initImplicitFlow', error);\n        this.inImplicitFlow = false;\n      });\n    }\n    /**\r\n     * Starts the implicit flow and redirects to user to\r\n     * the auth servers' login url.\r\n     *\r\n     * @param additionalState Optional state that is passed around.\r\n     *  You'll find this state in the property `state` after `tryLogin` logged in the user.\r\n     * @param params Hash with additional parameter. If it is a string, it is used for the\r\n     *               parameter loginHint (for the sake of compatibility with former versions)\r\n     */\n\n\n    initImplicitFlow(additionalState = '', params = '') {\n      if (this.loginUrl !== '') {\n        this.initImplicitFlowInternal(additionalState, params);\n      } else {\n        this.events.pipe(filter(e => e.type === 'discovery_document_loaded')).subscribe(_ => this.initImplicitFlowInternal(additionalState, params));\n      }\n    }\n    /**\r\n     * Reset current implicit flow\r\n     *\r\n     * @description This method allows resetting the current implict flow in order to be initialized again.\r\n     */\n\n\n    resetImplicitFlow() {\n      this.inImplicitFlow = false;\n    }\n\n    callOnTokenReceivedIfExists(options) {\n      const that = this;\n\n      if (options.onTokenReceived) {\n        const tokenParams = {\n          idClaims: that.getIdentityClaims(),\n          idToken: that.getIdToken(),\n          accessToken: that.getAccessToken(),\n          state: that.state\n        };\n        options.onTokenReceived(tokenParams);\n      }\n    }\n\n    storeAccessTokenResponse(accessToken, refreshToken, expiresIn, grantedScopes, customParameters) {\n      this._storage.setItem('access_token', accessToken);\n\n      if (grantedScopes && !Array.isArray(grantedScopes)) {\n        this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split(' ')));\n      } else if (grantedScopes && Array.isArray(grantedScopes)) {\n        this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes));\n      }\n\n      this._storage.setItem('access_token_stored_at', '' + this.dateTimeService.now());\n\n      if (expiresIn) {\n        const expiresInMilliSeconds = expiresIn * 1000;\n        const now = this.dateTimeService.new();\n        const expiresAt = now.getTime() + expiresInMilliSeconds;\n\n        this._storage.setItem('expires_at', '' + expiresAt);\n      }\n\n      if (refreshToken) {\n        this._storage.setItem('refresh_token', refreshToken);\n      }\n\n      if (customParameters) {\n        customParameters.forEach((value, key) => {\n          this._storage.setItem(key, value);\n        });\n      }\n    }\n    /**\r\n     * Delegates to tryLoginImplicitFlow for the sake of competability\r\n     * @param options Optional options.\r\n     */\n\n\n    tryLogin(options = null) {\n      if (this.config.responseType === 'code') {\n        return this.tryLoginCodeFlow(options).then(_ => true);\n      } else {\n        return this.tryLoginImplicitFlow(options);\n      }\n    }\n\n    parseQueryString(queryString) {\n      if (!queryString || queryString.length === 0) {\n        return {};\n      }\n\n      if (queryString.charAt(0) === '?') {\n        queryString = queryString.substr(1);\n      }\n\n      return this.urlHelper.parseQueryString(queryString);\n    }\n\n    tryLoginCodeFlow(options = null) {\n      var _this3 = this;\n\n      return _asyncToGenerator(function* () {\n        options = options || {};\n        const querySource = options.customHashFragment ? options.customHashFragment.substring(1) : window.location.search;\n\n        const parts = _this3.getCodePartsFromUrl(querySource);\n\n        const code = parts['code'];\n        const state = parts['state'];\n        const sessionState = parts['session_state'];\n\n        if (!options.preventClearHashAfterLogin) {\n          const href = location.origin + location.pathname + location.search.replace(/code=[^&\\$]*/, '').replace(/scope=[^&\\$]*/, '').replace(/state=[^&\\$]*/, '').replace(/session_state=[^&\\$]*/, '').replace(/^\\?&/, '?').replace(/&$/, '').replace(/^\\?$/, '').replace(/&+/g, '&').replace(/\\?&/, '?').replace(/\\?$/, '') + location.hash;\n          history.replaceState(null, window.name, href);\n        }\n\n        let [nonceInState, userState] = _this3.parseState(state);\n\n        _this3.state = userState;\n\n        if (parts['error']) {\n          _this3.debug('error trying to login');\n\n          _this3.handleLoginError(options, parts);\n\n          const err = new OAuthErrorEvent('code_error', {}, parts);\n\n          _this3.eventsSubject.next(err);\n\n          return Promise.reject(err);\n        }\n\n        if (!options.disableNonceCheck) {\n          if (!nonceInState) {\n            _this3.saveRequestedRoute();\n\n            return Promise.resolve();\n          }\n\n          if (!options.disableOAuth2StateCheck) {\n            const success = _this3.validateNonce(nonceInState);\n\n            if (!success) {\n              const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n\n              _this3.eventsSubject.next(event);\n\n              return Promise.reject(event);\n            }\n          }\n\n          _this3.storeSessionState(sessionState);\n\n          if (code) {\n            yield _this3.getTokenFromCode(code, options);\n\n            _this3.restoreRequestedRoute();\n\n            return Promise.resolve();\n          } else {\n            return Promise.resolve();\n          }\n        }\n\n        return Promise.reject();\n      })();\n    }\n\n    saveRequestedRoute() {\n      if (this.config.preserveRequestedRoute) {\n        this._storage.setItem('requested_route', window.location.pathname + window.location.search);\n      }\n    }\n\n    restoreRequestedRoute() {\n      const requestedRoute = this._storage.getItem('requested_route');\n\n      if (requestedRoute) {\n        history.replaceState(null, '', window.location.origin + requestedRoute);\n      }\n    }\n    /**\r\n     * Retrieve the returned auth code from the redirect uri that has been called.\r\n     * If required also check hash, as we could use hash location strategy.\r\n     */\n\n\n    getCodePartsFromUrl(queryString) {\n      if (!queryString || queryString.length === 0) {\n        return this.urlHelper.getHashFragmentParams();\n      } // normalize query string\n\n\n      if (queryString.charAt(0) === '?') {\n        queryString = queryString.substr(1);\n      }\n\n      return this.urlHelper.parseQueryString(queryString);\n    }\n    /**\r\n     * Get token using an intermediate code. Works for the Authorization Code flow.\r\n     */\n\n\n    getTokenFromCode(code, options) {\n      let params = new HttpParams({\n        encoder: new WebHttpUrlEncodingCodec()\n      }).set('grant_type', 'authorization_code').set('code', code).set('redirect_uri', options.customRedirectUri || this.redirectUri);\n\n      if (!this.disablePKCE) {\n        let PKCEVerifier;\n\n        if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n          PKCEVerifier = localStorage.getItem('PKCE_verifier');\n        } else {\n          PKCEVerifier = this._storage.getItem('PKCE_verifier');\n        }\n\n        if (!PKCEVerifier) {\n          console.warn('No PKCE verifier found in oauth storage!');\n        } else {\n          params = params.set('code_verifier', PKCEVerifier);\n        }\n      }\n\n      return this.fetchAndProcessToken(params, options);\n    }\n\n    fetchAndProcessToken(params, options) {\n      options = options || {};\n      this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n      let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n\n      return new Promise((resolve, reject) => {\n        if (this.customQueryParams) {\n          for (let key of Object.getOwnPropertyNames(this.customQueryParams)) {\n            params = params.set(key, this.customQueryParams[key]);\n          }\n        }\n\n        this.http.post(this.tokenEndpoint, params, {\n          headers\n        }).subscribe(tokenResponse => {\n          this.debug('refresh tokenResponse', tokenResponse);\n          this.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || this.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, this.extractRecognizedCustomParameters(tokenResponse));\n\n          if (this.oidc && tokenResponse.id_token) {\n            this.processIdToken(tokenResponse.id_token, tokenResponse.access_token, options.disableNonceCheck).then(result => {\n              this.storeIdToken(result);\n              this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n              this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n              resolve(tokenResponse);\n            }).catch(reason => {\n              this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n              console.error('Error validating tokens');\n              console.error(reason);\n              reject(reason);\n            });\n          } else {\n            this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n            this.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n            resolve(tokenResponse);\n          }\n        }, err => {\n          console.error('Error getting token', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n          reject(err);\n        });\n      });\n    }\n    /**\r\n     * Checks whether there are tokens in the hash fragment\r\n     * as a result of the implicit flow. These tokens are\r\n     * parsed, validated and used to sign the user in to the\r\n     * current client.\r\n     *\r\n     * @param options Optional options.\r\n     */\n\n\n    tryLoginImplicitFlow(options = null) {\n      options = options || {};\n      let parts;\n\n      if (options.customHashFragment) {\n        parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n      } else {\n        parts = this.urlHelper.getHashFragmentParams();\n      }\n\n      this.debug('parsed url', parts);\n      const state = parts['state'];\n      let [nonceInState, userState] = this.parseState(state);\n      this.state = userState;\n\n      if (parts['error']) {\n        this.debug('error trying to login');\n        this.handleLoginError(options, parts);\n        const err = new OAuthErrorEvent('token_error', {}, parts);\n        this.eventsSubject.next(err);\n        return Promise.reject(err);\n      }\n\n      const accessToken = parts['access_token'];\n      const idToken = parts['id_token'];\n      const sessionState = parts['session_state'];\n      const grantedScopes = parts['scope'];\n\n      if (!this.requestAccessToken && !this.oidc) {\n        return Promise.reject('Either requestAccessToken or oidc (or both) must be true.');\n      }\n\n      if (this.requestAccessToken && !accessToken) {\n        return Promise.resolve(false);\n      }\n\n      if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n        return Promise.resolve(false);\n      }\n\n      if (this.oidc && !idToken) {\n        return Promise.resolve(false);\n      }\n\n      if (this.sessionChecksEnabled && !sessionState) {\n        this.logger.warn('session checks (Session Status Change Notification) ' + 'were activated in the configuration but the id_token ' + 'does not contain a session_state claim');\n      }\n\n      if (this.requestAccessToken && !options.disableNonceCheck) {\n        const success = this.validateNonce(nonceInState);\n\n        if (!success) {\n          const event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n          this.eventsSubject.next(event);\n          return Promise.reject(event);\n        }\n      }\n\n      if (this.requestAccessToken) {\n        this.storeAccessTokenResponse(accessToken, null, parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec, grantedScopes);\n      }\n\n      if (!this.oidc) {\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n          this.clearLocationHash();\n        }\n\n        this.callOnTokenReceivedIfExists(options);\n        return Promise.resolve(true);\n      }\n\n      return this.processIdToken(idToken, accessToken, options.disableNonceCheck).then(result => {\n        if (options.validationHandler) {\n          return options.validationHandler({\n            accessToken: accessToken,\n            idClaims: result.idTokenClaims,\n            idToken: result.idToken,\n            state: state\n          }).then(_ => result);\n        }\n\n        return result;\n      }).then(result => {\n        this.storeIdToken(result);\n        this.storeSessionState(sessionState);\n\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n          this.clearLocationHash();\n        }\n\n        this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n        this.callOnTokenReceivedIfExists(options);\n        this.inImplicitFlow = false;\n        return true;\n      }).catch(reason => {\n        this.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n        this.logger.error('Error validating tokens');\n        this.logger.error(reason);\n        return Promise.reject(reason);\n      });\n    }\n\n    parseState(state) {\n      let nonce = state;\n      let userState = '';\n\n      if (state) {\n        const idx = state.indexOf(this.config.nonceStateSeparator);\n\n        if (idx > -1) {\n          nonce = state.substr(0, idx);\n          userState = state.substr(idx + this.config.nonceStateSeparator.length);\n        }\n      }\n\n      return [nonce, userState];\n    }\n\n    validateNonce(nonceInState) {\n      let savedNonce;\n\n      if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n        savedNonce = localStorage.getItem('nonce');\n      } else {\n        savedNonce = this._storage.getItem('nonce');\n      }\n\n      if (savedNonce !== nonceInState) {\n        const err = 'Validating access_token failed, wrong state/nonce.';\n        console.error(err, savedNonce, nonceInState);\n        return false;\n      }\n\n      return true;\n    }\n\n    storeIdToken(idToken) {\n      this._storage.setItem('id_token', idToken.idToken);\n\n      this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n\n      this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n\n      this._storage.setItem('id_token_stored_at', '' + this.dateTimeService.now());\n    }\n\n    storeSessionState(sessionState) {\n      this._storage.setItem('session_state', sessionState);\n    }\n\n    getSessionState() {\n      return this._storage.getItem('session_state');\n    }\n\n    handleLoginError(options, parts) {\n      if (options.onLoginError) {\n        options.onLoginError(parts);\n      }\n\n      if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n        this.clearLocationHash();\n      }\n    }\n\n    getClockSkewInMsec(defaultSkewMsc = 600000) {\n      if (!this.clockSkewInSec) {\n        return defaultSkewMsc;\n      }\n\n      return this.clockSkewInSec * 1000;\n    }\n    /**\r\n     * @ignore\r\n     */\n\n\n    processIdToken(idToken, accessToken, skipNonceCheck = false) {\n      const tokenParts = idToken.split('.');\n      const headerBase64 = this.padBase64(tokenParts[0]);\n      const headerJson = b64DecodeUnicode(headerBase64);\n      const header = JSON.parse(headerJson);\n      const claimsBase64 = this.padBase64(tokenParts[1]);\n      const claimsJson = b64DecodeUnicode(claimsBase64);\n      const claims = JSON.parse(claimsJson);\n      let savedNonce;\n\n      if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n        savedNonce = localStorage.getItem('nonce');\n      } else {\n        savedNonce = this._storage.getItem('nonce');\n      }\n\n      if (Array.isArray(claims.aud)) {\n        if (claims.aud.every(v => v !== this.clientId)) {\n          const err = 'Wrong audience: ' + claims.aud.join(',');\n          this.logger.warn(err);\n          return Promise.reject(err);\n        }\n      } else {\n        if (claims.aud !== this.clientId) {\n          const err = 'Wrong audience: ' + claims.aud;\n          this.logger.warn(err);\n          return Promise.reject(err);\n        }\n      }\n\n      if (!claims.sub) {\n        const err = 'No sub claim in id_token';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n      /* For now, we only check whether the sub against\r\n       * silentRefreshSubject when sessionChecksEnabled is on\r\n       * We will reconsider in a later version to do this\r\n       * in every other case too.\r\n       */\n\n\n      if (this.sessionChecksEnabled && this.silentRefreshSubject && this.silentRefreshSubject !== claims['sub']) {\n        const err = 'After refreshing, we got an id_token for another user (sub). ' + `Expected sub: ${this.silentRefreshSubject}, received sub: ${claims['sub']}`;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n\n      if (!claims.iat) {\n        const err = 'No iat claim in id_token';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n\n      if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n        const err = 'Wrong issuer: ' + claims.iss;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n\n      if (!skipNonceCheck && claims.nonce !== savedNonce) {\n        const err = 'Wrong nonce: ' + claims.nonce;\n        this.logger.warn(err);\n        return Promise.reject(err);\n      } // at_hash is not applicable to authorization code flow\n      // addressing https://github.com/manfredsteyer/angular-oauth2-oidc/issues/661\n      // i.e. Based on spec the at_hash check is only true for implicit code flow on Ping Federate\n      // https://www.pingidentity.com/developer/en/resources/openid-connect-developers-guide.html\n\n\n      if (this.hasOwnProperty('responseType') && (this.responseType === 'code' || this.responseType === 'id_token')) {\n        this.disableAtHashCheck = true;\n      }\n\n      if (!this.disableAtHashCheck && this.requestAccessToken && !claims['at_hash']) {\n        const err = 'An at_hash is needed!';\n        this.logger.warn(err);\n        return Promise.reject(err);\n      }\n\n      const now = this.dateTimeService.now();\n      const issuedAtMSec = claims.iat * 1000;\n      const expiresAtMSec = claims.exp * 1000;\n      const clockSkewInMSec = this.getClockSkewInMsec(); // (this.getClockSkewInMsec() || 600) * 1000;\n\n      if (issuedAtMSec - clockSkewInMSec >= now || expiresAtMSec + clockSkewInMSec <= now) {\n        const err = 'Token has expired';\n        console.error(err);\n        console.error({\n          now: now,\n          issuedAtMSec: issuedAtMSec,\n          expiresAtMSec: expiresAtMSec\n        });\n        return Promise.reject(err);\n      }\n\n      const validationParams = {\n        accessToken: accessToken,\n        idToken: idToken,\n        jwks: this.jwks,\n        idTokenClaims: claims,\n        idTokenHeader: header,\n        loadKeys: () => this.loadJwks()\n      };\n\n      if (this.disableAtHashCheck) {\n        return this.checkSignature(validationParams).then(_ => {\n          const result = {\n            idToken: idToken,\n            idTokenClaims: claims,\n            idTokenClaimsJson: claimsJson,\n            idTokenHeader: header,\n            idTokenHeaderJson: headerJson,\n            idTokenExpiresAt: expiresAtMSec\n          };\n          return result;\n        });\n      }\n\n      return this.checkAtHash(validationParams).then(atHashValid => {\n        if (!this.disableAtHashCheck && this.requestAccessToken && !atHashValid) {\n          const err = 'Wrong at_hash';\n          this.logger.warn(err);\n          return Promise.reject(err);\n        }\n\n        return this.checkSignature(validationParams).then(_ => {\n          const atHashCheckEnabled = !this.disableAtHashCheck;\n          const result = {\n            idToken: idToken,\n            idTokenClaims: claims,\n            idTokenClaimsJson: claimsJson,\n            idTokenHeader: header,\n            idTokenHeaderJson: headerJson,\n            idTokenExpiresAt: expiresAtMSec\n          };\n\n          if (atHashCheckEnabled) {\n            return this.checkAtHash(validationParams).then(atHashValid => {\n              if (this.requestAccessToken && !atHashValid) {\n                const err = 'Wrong at_hash';\n                this.logger.warn(err);\n                return Promise.reject(err);\n              } else {\n                return result;\n              }\n            });\n          } else {\n            return result;\n          }\n        });\n      });\n    }\n    /**\r\n     * Returns the received claims about the user.\r\n     */\n\n\n    getIdentityClaims() {\n      const claims = this._storage.getItem('id_token_claims_obj');\n\n      if (!claims) {\n        return null;\n      }\n\n      return JSON.parse(claims);\n    }\n    /**\r\n     * Returns the granted scopes from the server.\r\n     */\n\n\n    getGrantedScopes() {\n      const scopes = this._storage.getItem('granted_scopes');\n\n      if (!scopes) {\n        return null;\n      }\n\n      return JSON.parse(scopes);\n    }\n    /**\r\n     * Returns the current id_token.\r\n     */\n\n\n    getIdToken() {\n      return this._storage ? this._storage.getItem('id_token') : null;\n    }\n\n    padBase64(base64data) {\n      while (base64data.length % 4 !== 0) {\n        base64data += '=';\n      }\n\n      return base64data;\n    }\n    /**\r\n     * Returns the current access_token.\r\n     */\n\n\n    getAccessToken() {\n      return this._storage ? this._storage.getItem('access_token') : null;\n    }\n\n    getRefreshToken() {\n      return this._storage ? this._storage.getItem('refresh_token') : null;\n    }\n    /**\r\n     * Returns the expiration date of the access_token\r\n     * as milliseconds since 1970.\r\n     */\n\n\n    getAccessTokenExpiration() {\n      if (!this._storage.getItem('expires_at')) {\n        return null;\n      }\n\n      return parseInt(this._storage.getItem('expires_at'), 10);\n    }\n\n    getAccessTokenStoredAt() {\n      return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n    }\n\n    getIdTokenStoredAt() {\n      return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n    }\n    /**\r\n     * Returns the expiration date of the id_token\r\n     * as milliseconds since 1970.\r\n     */\n\n\n    getIdTokenExpiration() {\n      if (!this._storage.getItem('id_token_expires_at')) {\n        return null;\n      }\n\n      return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n    }\n    /**\r\n     * Checkes, whether there is a valid access_token.\r\n     */\n\n\n    hasValidAccessToken() {\n      if (this.getAccessToken()) {\n        const expiresAt = this._storage.getItem('expires_at');\n\n        const now = this.dateTimeService.new();\n\n        if (expiresAt && parseInt(expiresAt, 10) < now.getTime() - this.getClockSkewInMsec()) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Checks whether there is a valid id_token.\r\n     */\n\n\n    hasValidIdToken() {\n      if (this.getIdToken()) {\n        const expiresAt = this._storage.getItem('id_token_expires_at');\n\n        const now = this.dateTimeService.new();\n\n        if (expiresAt && parseInt(expiresAt, 10) < now.getTime() - this.getClockSkewInMsec()) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\r\n     * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\r\n     */\n\n\n    getCustomTokenResponseProperty(requestedProperty) {\n      return this._storage && this.config.customTokenParameters && this.config.customTokenParameters.indexOf(requestedProperty) >= 0 && this._storage.getItem(requestedProperty) !== null ? JSON.parse(this._storage.getItem(requestedProperty)) : null;\n    }\n    /**\r\n     * Returns the auth-header that can be used\r\n     * to transmit the access_token to a service\r\n     */\n\n\n    authorizationHeader() {\n      return 'Bearer ' + this.getAccessToken();\n    }\n\n    logOut(customParameters = {}, state = '') {\n      let noRedirectToLogoutUrl = false;\n\n      if (typeof customParameters === 'boolean') {\n        noRedirectToLogoutUrl = customParameters;\n        customParameters = {};\n      }\n\n      const id_token = this.getIdToken();\n\n      this._storage.removeItem('access_token');\n\n      this._storage.removeItem('id_token');\n\n      this._storage.removeItem('refresh_token');\n\n      if (this.saveNoncesInLocalStorage) {\n        localStorage.removeItem('nonce');\n        localStorage.removeItem('PKCE_verifier');\n      } else {\n        this._storage.removeItem('nonce');\n\n        this._storage.removeItem('PKCE_verifier');\n      }\n\n      this._storage.removeItem('expires_at');\n\n      this._storage.removeItem('id_token_claims_obj');\n\n      this._storage.removeItem('id_token_expires_at');\n\n      this._storage.removeItem('id_token_stored_at');\n\n      this._storage.removeItem('access_token_stored_at');\n\n      this._storage.removeItem('granted_scopes');\n\n      this._storage.removeItem('session_state');\n\n      if (this.config.customTokenParameters) {\n        this.config.customTokenParameters.forEach(customParam => this._storage.removeItem(customParam));\n      }\n\n      this.silentRefreshSubject = null;\n      this.eventsSubject.next(new OAuthInfoEvent('logout'));\n\n      if (!this.logoutUrl) {\n        return;\n      }\n\n      if (noRedirectToLogoutUrl) {\n        return;\n      }\n\n      if (!id_token && !this.postLogoutRedirectUri) {\n        return;\n      }\n\n      let logoutUrl;\n\n      if (!this.validateUrlForHttps(this.logoutUrl)) {\n        throw new Error(\"logoutUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      } // For backward compatibility\n\n\n      if (this.logoutUrl.indexOf('{{') > -1) {\n        logoutUrl = this.logoutUrl.replace(/\\{\\{id_token\\}\\}/, encodeURIComponent(id_token)).replace(/\\{\\{client_id\\}\\}/, encodeURIComponent(this.clientId));\n      } else {\n        let params = new HttpParams({\n          encoder: new WebHttpUrlEncodingCodec()\n        });\n\n        if (id_token) {\n          params = params.set('id_token_hint', id_token);\n        }\n\n        const postLogoutUrl = this.postLogoutRedirectUri || this.redirectUriAsPostLogoutRedirectUriFallback && this.redirectUri || '';\n\n        if (postLogoutUrl) {\n          params = params.set('post_logout_redirect_uri', postLogoutUrl);\n\n          if (state) {\n            params = params.set('state', state);\n          }\n        }\n\n        for (let key in customParameters) {\n          params = params.set(key, customParameters[key]);\n        }\n\n        logoutUrl = this.logoutUrl + (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') + params.toString();\n      }\n\n      this.config.openUri(logoutUrl);\n    }\n    /**\r\n     * @ignore\r\n     */\n\n\n    createAndSaveNonce() {\n      const that = this;\n      return this.createNonce().then(function (nonce) {\n        // Use localStorage for nonce if possible\n        // localStorage is the only storage who survives a\n        // redirect in ALL browsers (also IE)\n        // Otherwiese we'd force teams who have to support\n        // IE into using localStorage for everything\n        if (that.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n          localStorage.setItem('nonce', nonce);\n        } else {\n          that._storage.setItem('nonce', nonce);\n        }\n\n        return nonce;\n      });\n    }\n    /**\r\n     * @ignore\r\n     */\n\n\n    ngOnDestroy() {\n      this.clearAccessTokenTimer();\n      this.clearIdTokenTimer();\n      this.removeSilentRefreshEventListener();\n      const silentRefreshFrame = this.document.getElementById(this.silentRefreshIFrameName);\n\n      if (silentRefreshFrame) {\n        silentRefreshFrame.remove();\n      }\n\n      this.stopSessionCheckTimer();\n      this.removeSessionCheckEventListener();\n      const sessionCheckFrame = this.document.getElementById(this.sessionCheckIFrameName);\n\n      if (sessionCheckFrame) {\n        sessionCheckFrame.remove();\n      }\n    }\n\n    createNonce() {\n      return new Promise(resolve => {\n        if (this.rngUrl) {\n          throw new Error('createNonce with rng-web-api has not been implemented so far');\n        }\n        /*\r\n         * This alphabet is from:\r\n         * https://tools.ietf.org/html/rfc7636#section-4.1\r\n         *\r\n         * [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\r\n         */\n\n\n        const unreserved = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n        let size = 45;\n        let id = '';\n        const crypto = typeof self === 'undefined' ? null : self.crypto || self['msCrypto'];\n\n        if (crypto) {\n          let bytes = new Uint8Array(size);\n          crypto.getRandomValues(bytes); // Needed for IE\n\n          if (!bytes.map) {\n            bytes.map = Array.prototype.map;\n          }\n\n          bytes = bytes.map(x => unreserved.charCodeAt(x % unreserved.length));\n          id = String.fromCharCode.apply(null, bytes);\n        } else {\n          while (0 < size--) {\n            id += unreserved[Math.random() * unreserved.length | 0];\n          }\n        }\n\n        resolve(base64UrlEncode(id));\n      });\n    }\n\n    checkAtHash(params) {\n      var _this4 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this4.tokenValidationHandler) {\n          _this4.logger.warn('No tokenValidationHandler configured. Cannot check at_hash.');\n\n          return true;\n        }\n\n        return _this4.tokenValidationHandler.validateAtHash(params);\n      })();\n    }\n\n    checkSignature(params) {\n      if (!this.tokenValidationHandler) {\n        this.logger.warn('No tokenValidationHandler configured. Cannot check signature.');\n        return Promise.resolve(null);\n      }\n\n      return this.tokenValidationHandler.validateSignature(params);\n    }\n    /**\r\n     * Start the implicit flow or the code flow,\r\n     * depending on your configuration.\r\n     */\n\n\n    initLoginFlow(additionalState = '', params = {}) {\n      if (this.responseType === 'code') {\n        return this.initCodeFlow(additionalState, params);\n      } else {\n        return this.initImplicitFlow(additionalState, params);\n      }\n    }\n    /**\r\n     * Starts the authorization code flow and redirects to user to\r\n     * the auth servers login url.\r\n     */\n\n\n    initCodeFlow(additionalState = '', params = {}) {\n      if (this.loginUrl !== '') {\n        this.initCodeFlowInternal(additionalState, params);\n      } else {\n        this.events.pipe(filter(e => e.type === 'discovery_document_loaded')).subscribe(_ => this.initCodeFlowInternal(additionalState, params));\n      }\n    }\n\n    initCodeFlowInternal(additionalState = '', params = {}) {\n      if (!this.validateUrlForHttps(this.loginUrl)) {\n        throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n      }\n\n      let addParams = {};\n      let loginHint = null;\n\n      if (typeof params === 'string') {\n        loginHint = params;\n      } else if (typeof params === 'object') {\n        addParams = params;\n      }\n\n      this.createLoginUrl(additionalState, loginHint, null, false, addParams).then(this.config.openUri).catch(error => {\n        console.error('Error in initAuthorizationCodeFlow');\n        console.error(error);\n      });\n    }\n\n    createChallangeVerifierPairForPKCE() {\n      var _this5 = this;\n\n      return _asyncToGenerator(function* () {\n        if (!_this5.crypto) {\n          throw new Error('PKCE support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\n        }\n\n        const verifier = yield _this5.createNonce();\n        const challengeRaw = yield _this5.crypto.calcHash(verifier, 'sha-256');\n        const challenge = base64UrlEncode(challengeRaw);\n        return [challenge, verifier];\n      })();\n    }\n\n    extractRecognizedCustomParameters(tokenResponse) {\n      let foundParameters = new Map();\n\n      if (!this.config.customTokenParameters) {\n        return foundParameters;\n      }\n\n      this.config.customTokenParameters.forEach(recognizedParameter => {\n        if (tokenResponse[recognizedParameter]) {\n          foundParameters.set(recognizedParameter, JSON.stringify(tokenResponse[recognizedParameter]));\n        }\n      });\n      return foundParameters;\n    }\n    /**\r\n     * Revokes the auth token to secure the vulnarability\r\n     * of the token issued allowing the authorization server to clean\r\n     * up any security credentials associated with the authorization\r\n     */\n\n\n    revokeTokenAndLogout(customParameters = {}, ignoreCorsIssues = false) {\n      let revokeEndpoint = this.revocationEndpoint;\n      let accessToken = this.getAccessToken();\n      let refreshToken = this.getRefreshToken();\n\n      if (!accessToken) {\n        return;\n      }\n\n      let params = new HttpParams({\n        encoder: new WebHttpUrlEncodingCodec()\n      });\n      let headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n      if (this.useHttpBasicAuth) {\n        const header = btoa(`${this.clientId}:${this.dummyClientSecret}`);\n        headers = headers.set('Authorization', 'Basic ' + header);\n      }\n\n      if (!this.useHttpBasicAuth) {\n        params = params.set('client_id', this.clientId);\n      }\n\n      if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n        params = params.set('client_secret', this.dummyClientSecret);\n      }\n\n      if (this.customQueryParams) {\n        for (const key of Object.getOwnPropertyNames(this.customQueryParams)) {\n          params = params.set(key, this.customQueryParams[key]);\n        }\n      }\n\n      return new Promise((resolve, reject) => {\n        let revokeAccessToken;\n        let revokeRefreshToken;\n\n        if (accessToken) {\n          let revokationParams = params.set('token', accessToken).set('token_type_hint', 'access_token');\n          revokeAccessToken = this.http.post(revokeEndpoint, revokationParams, {\n            headers\n          });\n        } else {\n          revokeAccessToken = of(null);\n        }\n\n        if (refreshToken) {\n          let revokationParams = params.set('token', refreshToken).set('token_type_hint', 'refresh_token');\n          revokeRefreshToken = this.http.post(revokeEndpoint, revokationParams, {\n            headers\n          });\n        } else {\n          revokeRefreshToken = of(null);\n        }\n\n        if (ignoreCorsIssues) {\n          revokeAccessToken = revokeAccessToken.pipe(catchError(err => {\n            if (err.status === 0) {\n              return of(null);\n            }\n\n            return throwError(err);\n          }));\n          revokeRefreshToken = revokeRefreshToken.pipe(catchError(err => {\n            if (err.status === 0) {\n              return of(null);\n            }\n\n            return throwError(err);\n          }));\n        }\n\n        combineLatest([revokeAccessToken, revokeRefreshToken]).subscribe(res => {\n          this.logOut(customParameters);\n          resolve(res);\n          this.logger.info('Token successfully revoked');\n        }, err => {\n          this.logger.error('Error revoking token', err);\n          this.eventsSubject.next(new OAuthErrorEvent('token_revoke_error', err));\n          reject(err);\n        });\n      });\n    }\n    /**\r\n     * Clear location.hash if it's present\r\n     */\n\n\n    clearLocationHash() {\n      // Checking for empty hash is necessary for Firefox\n      // as setting an empty hash to an empty string adds # to the URL\n      if (location.hash != '') {\n        location.hash = '';\n      }\n    }\n\n  }\n\n  OAuthService.ɵfac = function OAuthService_Factory(t) {\n    return new (t || OAuthService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OAuthStorage, 8), i0.ɵɵinject(ValidationHandler, 8), i0.ɵɵinject(AuthConfig, 8), i0.ɵɵinject(UrlHelperService), i0.ɵɵinject(OAuthLogger), i0.ɵɵinject(HashHandler, 8), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(DateTimeProvider));\n  };\n\n  OAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OAuthService,\n    factory: OAuthService.ɵfac\n  });\n  return OAuthService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass OAuthModuleConfig {}\n\nclass OAuthResourceServerConfig {}\n\nclass OAuthResourceServerErrorHandler {}\n\nclass OAuthNoopResourceServerErrorHandler {\n  handleError(err) {\n    return throwError(err);\n  }\n\n}\n\nlet DefaultOAuthInterceptor = /*#__PURE__*/(() => {\n  class DefaultOAuthInterceptor {\n    constructor(oAuthService, errorHandler, moduleConfig) {\n      this.oAuthService = oAuthService;\n      this.errorHandler = errorHandler;\n      this.moduleConfig = moduleConfig;\n    }\n\n    checkUrl(url) {\n      if (this.moduleConfig.resourceServer.customUrlValidation) {\n        return this.moduleConfig.resourceServer.customUrlValidation(url);\n      }\n\n      if (this.moduleConfig.resourceServer.allowedUrls) {\n        return !!this.moduleConfig.resourceServer.allowedUrls.find(u => url.toLowerCase().startsWith(u.toLowerCase()));\n      }\n\n      return true;\n    }\n\n    intercept(req, next) {\n      const url = req.url.toLowerCase();\n\n      if (!this.moduleConfig || !this.moduleConfig.resourceServer || !this.checkUrl(url)) {\n        return next.handle(req);\n      }\n\n      const sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n\n      if (!sendAccessToken) {\n        return next.handle(req).pipe(catchError(err => this.errorHandler.handleError(err)));\n      }\n\n      return merge(of(this.oAuthService.getAccessToken()).pipe(filter(token => !!token)), this.oAuthService.events.pipe(filter(e => e.type === 'token_received'), timeout(this.oAuthService.waitForTokenInMsec || 0), catchError(_ => of(null)), // timeout is not an error\n      map(_ => this.oAuthService.getAccessToken()))).pipe(take(1), mergeMap(token => {\n        if (token) {\n          const header = 'Bearer ' + token;\n          const headers = req.headers.set('Authorization', header);\n          req = req.clone({\n            headers\n          });\n        }\n\n        return next.handle(req).pipe(catchError(err => this.errorHandler.handleError(err)));\n      }));\n    }\n\n  }\n\n  DefaultOAuthInterceptor.ɵfac = function DefaultOAuthInterceptor_Factory(t) {\n    return new (t || DefaultOAuthInterceptor)(i0.ɵɵinject(OAuthService), i0.ɵɵinject(OAuthResourceServerErrorHandler), i0.ɵɵinject(OAuthModuleConfig, 8));\n  };\n\n  DefaultOAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultOAuthInterceptor,\n    factory: DefaultOAuthInterceptor.ɵfac\n  });\n  return DefaultOAuthInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * A validation handler that isn't validating nothing.\r\n * Can be used to skip validation (at your own risk).\r\n */\n\n\nclass NullValidationHandler {\n  validateSignature(validationParams) {\n    return Promise.resolve(null);\n  }\n\n  validateAtHash(validationParams) {\n    return Promise.resolve(true);\n  }\n\n}\n\nfunction createDefaultLogger() {\n  return console;\n}\n\nfunction createDefaultStorage() {\n  return typeof sessionStorage !== 'undefined' ? sessionStorage : new MemoryStorage();\n}\n\nlet OAuthModule = /*#__PURE__*/(() => {\n  class OAuthModule {\n    static forRoot(config = null, validationHandlerClass = NullValidationHandler) {\n      return {\n        ngModule: OAuthModule,\n        providers: [OAuthService, UrlHelperService, {\n          provide: OAuthLogger,\n          useFactory: createDefaultLogger\n        }, {\n          provide: OAuthStorage,\n          useFactory: createDefaultStorage\n        }, {\n          provide: ValidationHandler,\n          useClass: validationHandlerClass\n        }, {\n          provide: HashHandler,\n          useClass: DefaultHashHandler\n        }, {\n          provide: OAuthResourceServerErrorHandler,\n          useClass: OAuthNoopResourceServerErrorHandler\n        }, {\n          provide: OAuthModuleConfig,\n          useValue: config\n        }, {\n          provide: HTTP_INTERCEPTORS,\n          useClass: DefaultOAuthInterceptor,\n          multi: true\n        }, {\n          provide: DateTimeProvider,\n          useClass: SystemDateTimeProvider\n        }]\n      };\n    }\n\n  }\n\n  OAuthModule.ɵfac = function OAuthModule_Factory(t) {\n    return new (t || OAuthModule)();\n  };\n\n  OAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OAuthModule\n  });\n  OAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return OAuthModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst err = `PLEASE READ THIS CAREFULLY:\n\nBeginning with angular-oauth2-oidc version 9, the JwksValidationHandler\nhas been moved to an library of its own. If you need it for implementing\nOAuth2/OIDC **implicit flow**, please install it using npm:\n\n  npm i angular-oauth2-oidc-jwks --save\n\nAfter that, you can import it into your application:\n\n  import { JwksValidationHandler } from 'angular-oauth2-oidc-jwks';\n\nPlease note, that this dependency is not needed for the **code flow**,\nwhich is nowadays the **recommented** one for single page applications.\nThis also results in smaller bundle sizes.\n`;\n/**\r\n * This is just a dummy of the JwksValidationHandler\r\n * telling the users that the real one has been moved\r\n * to an library of its own, namely angular-oauth2-oidc-utils\r\n */\n\nclass JwksValidationHandler extends NullValidationHandler {\n  constructor() {\n    super();\n    console.error(err);\n  }\n\n}\n\nconst AUTH_CONFIG = new InjectionToken('AUTH_CONFIG');\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AUTH_CONFIG, AbstractValidationHandler, AuthConfig, DateTimeProvider, DefaultHashHandler, DefaultOAuthInterceptor, HashHandler, JwksValidationHandler, LoginOptions, MemoryStorage, NullValidationHandler, OAuthErrorEvent, OAuthEvent, OAuthInfoEvent, OAuthLogger, OAuthModule, OAuthModuleConfig, OAuthNoopResourceServerErrorHandler, OAuthResourceServerConfig, OAuthResourceServerErrorHandler, OAuthService, OAuthStorage, OAuthSuccessEvent, ReceivedTokens, SystemDateTimeProvider, UrlHelperService, ValidationHandler };","map":null,"metadata":{},"sourceType":"module"}